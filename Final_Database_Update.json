{
  "name": "Final_Database_Update",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        300,
        1460
      ],
      "id": "bbebc350-a219-4243-ae32-56c2211f49d9",
      "name": "When clicking ‚ÄòExecute workflow‚Äô"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "documents",
          "mode": "list",
          "cachedResultName": "documents"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1.3,
      "position": [
        1360,
        1460
      ],
      "id": "7af1a41e-e4b1-4ce2-a896-1cc281078487",
      "name": "Supabase Vector Store1",
      "credentials": {
        "supabaseApi": {
          "id": "Oppa6T4QrszeOPwR",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $('Code').item.json.pageContent }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "caseNumber",
                "value": "={{ $('Code').item.json.metadata.caseNumber }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1.1,
      "position": [
        1480,
        1660
      ],
      "id": "e48fd3b8-7670-44c9-8c5a-3dc3ea76ef8d",
      "name": "Default Data Loader"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        1300,
        1660
      ],
      "id": "beb902fe-5104-4f86-8f39-18582f62aee4",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "XaTkzUzofDnfl1QT",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        720,
        1460
      ],
      "id": "ed73fce4-880a-4b85-9a03-18febd62fdbf",
      "name": "Download file1",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BUIrZv2AD9CqbQhb",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        920,
        1460
      ],
      "id": "5bcdd80c-50e4-4019-b0f6-7bd6a7ecce89",
      "name": "Extract from File1"
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "filter": {
          "folderId": {
            "__rl": true,
            "value": "1X1zcg9RRw7c7pHXDcTRM6avfc3rhkUQa",
            "mode": "list",
            "cachedResultName": "PDF to json Database",
            "cachedResultUrl": "https://drive.google.com/drive/folders/1X1zcg9RRw7c7pHXDcTRM6avfc3rhkUQa"
          }
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        520,
        1460
      ],
      "id": "6b252dcc-530f-4b62-b256-fb9970c4d3ce",
      "name": "Search files and folders1",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BUIrZv2AD9CqbQhb",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Fixed Version - Court Case Document Splitter with Unicode handling\nconst items = [];\n\n// Helper function to safely escape text for JSON/Vector store\nfunction sanitizeText(text) {\n  if (!text || typeof text !== 'string') return '';\n  \n  return text\n    // Remove null characters and other control characters\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '')\n    // Fix common Unicode escape issues\n    .replace(/\\\\(?![\\\\/\"'bfnrt]|u[0-9a-fA-F]{4})/g, '\\\\\\\\')\n    // Normalize Unicode characters\n    .normalize('NFC')\n    // Remove any remaining problematic sequences\n    .replace(/\\\\u(?![0-9a-fA-F]{4})/g, '\\\\\\\\u')\n    // Escape quotes safely\n    .replace(/\"/g, '\\\\\"')\n    // Clean up excessive whitespace\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n// Helper function to create safe metadata\nfunction createSafeMetadata(data) {\n  const safe = {};\n  for (const [key, value] of Object.entries(data)) {\n    if (typeof value === 'string') {\n      safe[key] = sanitizeText(value);\n    } else if (typeof value === 'object' && value !== null) {\n      safe[key] = createSafeMetadata(value);\n    } else {\n      safe[key] = value;\n    }\n  }\n  return safe;\n}\n\ntry {\n  console.log('=== DEBUGGING START ===');\n  console.log('Input items count:', $input.all().length);\n  \n  for (let itemIndex = 0; itemIndex < $input.all().length; itemIndex++) {\n    const item = $input.all()[itemIndex];\n    console.log(`\\n--- Processing Item ${itemIndex + 1} ---`);\n    console.log('Item structure:', Object.keys(item));\n    console.log('JSON keys:', Object.keys(item.json || {}));\n    \n    // Try to find text in various possible properties\n    let inputText = '';\n    const possibleTextFields = ['text', 'content', 'data', 'body', 'message', 'document'];\n    \n    for (const field of possibleTextFields) {\n      if (item.json && item.json[field]) {\n        inputText = String(item.json[field]);\n        console.log(`Found text in field: ${field}`);\n        console.log(`Text length: ${inputText.length}`);\n        break;\n      }\n    }\n    \n    // If no text found in expected fields, try the whole JSON\n    if (!inputText) {\n      try {\n        inputText = JSON.stringify(item.json);\n        console.log('Using entire JSON as text');\n        console.log(`JSON text length: ${inputText.length}`);\n      } catch (jsonError) {\n        console.error('JSON stringify error:', jsonError.message);\n        inputText = String(item.json || '');\n      }\n    }\n    \n    // Sanitize the input text early\n    const originalLength = inputText.length;\n    inputText = sanitizeText(inputText);\n    console.log(`Text sanitized: ${originalLength} -> ${inputText.length} characters`);\n    \n    // Show sample of text being searched for debugging\n    console.log('\\n=== FULL INPUT TEXT ANALYSIS ===');\n    console.log('Total text length:', inputText.length);\n    console.log('First 500 characters:');\n    console.log(inputText.substring(0, 500));\n    console.log('\\n--- Looking for all case number patterns in text ---');\n    \n    // Find ALL potential case numbers in the text to see what's available\n    const allCaseNumbers = [];\n    const globalPattern = /(\\d+(?:\\s*-\\s*\\d+)?\\/\\d{4})/g;\n    let match;\n    while ((match = globalPattern.exec(inputText)) !== null) {\n      allCaseNumbers.push({\n        number: match[1],\n        position: match.index,\n        context: inputText.substring(Math.max(0, match.index - 40), Math.min(inputText.length, match.index + match[0].length + 40))\n      });\n    }\n    \n    console.log(`Found ${allCaseNumbers.length} potential case numbers in text:`);\n    allCaseNumbers.forEach((item, i) => {\n      console.log(`  ${i + 1}. \"${item.number}\" at position ${item.position}`);\n      console.log(`     Context: \"${item.context}\"`);\n    });\n    \n    // Show which one appears in ‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤ context\n    const headerPattern = /(?:‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤|‡∏Ñ‡πç‡∏≤‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤)[^‡∏Å-‡πô]*?(\\d+(?:\\s*-\\s*\\d+)?\\/\\d{4})/gi;\n    const headerMatches = [];\n    let headerMatch;\n    while ((headerMatch = headerPattern.exec(inputText)) !== null) {\n      headerMatches.push({\n        fullMatch: headerMatch[0],\n        caseNumber: headerMatch[1],\n        position: headerMatch.index\n      });\n    }\n    \n    console.log(`\\nüìã MAIN JUDGMENT HEADERS FOUND:`);\n    if (headerMatches.length > 0) {\n      headerMatches.forEach((item, i) => {\n        console.log(`  ${i + 1}. \"${item.caseNumber}\" in context: \"${item.fullMatch}\"`);\n      });\n    } else {\n      console.log('  ‚ùå No main judgment headers found');\n    }\n    console.log('=== END ANALYSIS ===\\n');\n    \n    // Test different patterns to find court cases - fixed to prioritize main case headers\n    const patterns = [\n      // Pattern 1: Main judgment header with range support (5234 - 5238/2566) - both spellings\n      /(?:‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤|‡∏Ñ‡πç‡∏≤‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤)‡∏®‡∏≤‡∏•‡∏é‡∏µ‡∏Å‡∏≤‡∏ó‡∏µ‡πà?\\s*(\\d+(?:\\s*-\\s*\\d+)?\\/\\d{4})/gi,\n      // Pattern 2: General judgment header\n      /(?:‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤|‡∏Ñ‡πç‡∏≤‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤)[^‡∏Å-‡πô]*?‡∏ó‡∏µ‡πà?\\s*(\\d+(?:\\s*-\\s*\\d+)?\\/\\d{4})/gi,\n      // Pattern 3: Simple case numbers as fallback (but less priority)\n      /\\b(\\d+(?:\\s*-\\s*\\d+)?\\/\\d{4})\\b/g\n    ];\n    \n    let foundCases = [];\n    \n    for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {\n      const pattern = patterns[patternIndex];\n      console.log(`\\nTesting pattern ${patternIndex + 1}:`, pattern.source);\n      \n      const matches = [];\n      let match;\n      const tempPattern = new RegExp(pattern.source, pattern.flags);\n      \n      while ((match = tempPattern.exec(inputText)) !== null) {\n        // Extract case number properly - always use the captured group for case number\n        let caseNumber, fullMatch;\n        \n        if (match[1]) {\n          // If we have a capture group, use it for case number\n          caseNumber = sanitizeText(match[1]);\n          fullMatch = sanitizeText(match[0]);\n        } else {\n          // If no capture group, the whole match is the case number\n          caseNumber = sanitizeText(match[0]);\n          fullMatch = sanitizeText(match[0]);\n        }\n        \n        // Show more context around the match to debug what's being found\n        const contextStart = Math.max(0, match.index - 50);\n        const contextEnd = Math.min(inputText.length, match.index + match[0].length + 50);\n        const context = sanitizeText(inputText.substring(contextStart, contextEnd));\n        \n        console.log(`  üîç Match details:`);\n        console.log(`    Original text around match: \"${inputText.substring(contextStart, contextEnd)}\"`);\n        console.log(`    Full regex match: \"${match[0]}\"`);\n        console.log(`    Capture group 1: \"${match[1] || 'none'}\"`);\n        console.log(`    Extracted case number: \"${caseNumber}\"`);\n        console.log(`    Match position: ${match.index}-${match.index + match[0].length}`);\n        console.log(`    ---`);\n        \n        matches.push({\n          fullMatch: fullMatch,\n          caseNumber: caseNumber,\n          index: match.index,\n          context: context\n        });\n        \n        // Prevent infinite loop\n        if (!pattern.global) break;\n      }\n      \n      console.log(`Pattern ${patternIndex + 1} found ${matches.length} matches`);\n      \n      if (matches.length > 0) {\n        foundCases = matches;\n        console.log('Matches found:');\n        matches.forEach((m, i) => {\n          console.log(`  ${i + 1}. \"${m.fullMatch}\" at position ${m.index}`);\n          console.log(`     Context: \"${m.context}\"`);\n        });\n        break; // Use the first pattern that finds matches\n      }\n    }\n    \n    if (foundCases.length > 0) {\n      console.log(`\\n‚úÖ Found ${foundCases.length} court cases, creating items...`);\n      \n      // Create a simple item for each case found\n      foundCases.forEach((caseData, index) => {\n        const startIndex = caseData.index;\n        const nextCase = foundCases[index + 1];\n        const endIndex = nextCase ? nextCase.index : inputText.length;\n        \n        let caseContent = inputText.substring(startIndex, endIndex).trim();\n        caseContent = sanitizeText(caseContent);\n        \n        // Create simple markdown with safe content\n        const safeHeader = sanitizeText(caseData.caseNumber); // Use case number for header\n        const safeCaseNumber = sanitizeText(caseData.caseNumber);\n        const safeFullMatch = sanitizeText(caseData.fullMatch);\n        \n        console.log(`Creating markdown for case: \"${safeCaseNumber}\"`);\n        console.log(`Header will be: \"${safeHeader}\"`);\n        console.log(`Full match was: \"${safeFullMatch}\"`);\n        \n        const markdown = `# ‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤‡∏ó‡∏µ‡πà ${safeHeader}\n\n> **‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤‡∏ó‡∏µ‡πà:** ${safeCaseNumber}\n\n## ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤\n\n${caseContent}\n\n---\n*‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏û‡∏¥‡∏û‡∏≤‡∏Å‡∏©‡∏≤‡∏ó‡∏µ‡πà ${safeCaseNumber}*`;\n        \n        // Create safe metadata\n        const safeMetadata = createSafeMetadata({\n          caseNumber: caseData.caseNumber,\n          fullHeader: caseData.fullMatch,\n          chunkIndex: 1,\n          totalChunks: 1,\n          contentLength: caseContent.length,\n          debug: {\n            itemIndex: itemIndex,\n            caseIndex: index,\n            startIndex: startIndex,\n            endIndex: endIndex\n          }\n        });\n        \n        // Final sanitization of the entire pageContent\n        const finalPageContent = sanitizeText(markdown);\n        \n        items.push({\n          json: {\n            pageContent: finalPageContent,\n            metadata: safeMetadata\n          }\n        });\n        \n        console.log(`‚úÖ Created item for case: ${safeCaseNumber}`);\n        console.log(`   Header: \"${safeHeader}\"`);\n        console.log(`   Page content length: ${finalPageContent.length}`);\n        console.log(`   Content starts with: \"${finalPageContent.substring(0, 100)}...\"`);\n\n      });\n      \n    } else {\n      console.log('‚ùå No court cases found with any pattern');\n      \n      // Create a debug item to see what we got (safely)\n      const debugContent = sanitizeText(inputText.substring(0, 1000));\n      const safeMetadata = createSafeMetadata({\n        debug: true,\n        inputLength: inputText.length,\n        itemIndex: itemIndex,\n        message: 'No court cases found in this item'\n      });\n      \n      items.push({\n        json: {\n          pageContent: `Debug: No cases found\\n\\nFirst 1000 chars:\\n${debugContent}`,\n          metadata: safeMetadata\n        }\n      });\n    }\n  }\n  \n  console.log(`\\n=== FINAL RESULT ===`);\n  console.log(`Created ${items.length} output items`);\n  \n  // Show summary of all extracted case numbers\n  const extractedCases = items\n    .filter(item => item.json.metadata && item.json.metadata.caseNumber)\n    .map(item => item.json.metadata.caseNumber);\n  \n  if (extractedCases.length > 0) {\n    console.log(`\\nüìã EXTRACTED CASE NUMBERS SUMMARY:`);\n    extractedCases.forEach((caseNum, i) => {\n      console.log(`   ${i + 1}. ${caseNum}`);\n    });\n  } else {\n    console.log(`‚ö†Ô∏è  No case numbers were extracted`);\n  }\n  \n  // Final validation of all items\n  items.forEach((item, index) => {\n    try {\n      JSON.stringify(item);\n      console.log(`Item ${index + 1}: JSON validation passed`);\n    } catch (validationError) {\n      console.error(`Item ${index + 1}: JSON validation failed:`, validationError.message);\n      // Fix the problematic item\n      item.json.pageContent = 'Content validation failed - removed problematic characters';\n      item.json.metadata = { error: 'Content sanitization failed', index: index };\n    }\n  });\n  \n} catch (error) {\n  console.error('ERROR in processing:', error);\n  const safeErrorMessage = sanitizeText(error.message || 'Unknown error');\n  const safeErrorStack = sanitizeText(error.stack || 'No stack trace');\n  \n  items.push({\n    json: {\n      pageContent: `Error: ${safeErrorMessage}`,\n      metadata: {\n        error: true,\n        errorMessage: safeErrorMessage,\n        errorStack: safeErrorStack\n      }\n    }\n  });\n}\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1140,
        1460
      ],
      "id": "a9ca2bac-2847-40cd-a0e1-322b5b9f2048",
      "name": "Code",
      "alwaysOutputData": true
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‚ÄòExecute workflow‚Äô": {
      "main": [
        [
          {
            "node": "Search files and folders1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Supabase Vector Store1",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "Supabase Vector Store1",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Download file1": {
      "main": [
        [
          {
            "node": "Extract from File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File1": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search files and folders1": {
      "main": [
        [
          {
            "node": "Download file1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Supabase Vector Store1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "bc232eca-2f83-4251-ab7e-7cbb32e206cc",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "244ba1cfe08b06cf03691cd3c17f52b13bb5abbfc7d8fecc9464e5a3103be712"
  },
  "id": "rRLCwnr3w0zW1cl1",
  "tags": []
}